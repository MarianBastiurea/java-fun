/*
General Information

JDK means Java Development Kit
JVM means Java Virtual Machine
Statement is complete command to be executed
Keyword is any one of a number of reserved word, that have a predefined meaning in Java
Keywords need to be in lowercase
Variables are a way to store information in computer

Expression

Expression- computes to a single value
Statements- Stand alone units of work
Whitespace- spaces around code ignored by Java and it's purpose for human readability
Reformat code- change code format to be more easy to read
Declaration Statement is used to define a variable by indicating the data type, name and eventually set a value
Expression is a coding construct, that evaluates a single value
Expression is a code segment in Right side of equals sign in assign or declaration statement
Class is a building blocks for object-oriented programming
Overflow and Underflow is a value larger or lower than maximum or minimum value of an int, double,etc.
A numeric literal that exceeds maximum value of int should have "L" as suffix.
Cannot declare variables with different data type in a single statement
If you declare multiple variables with same data type, you have to declare data types only once before any variables name
The Java compiler does not attempt to evaluate the value in a variable when it's used in a calculation, so it's
doesn't know if the value fits, and throws an error
Casting means to convert a number from one type to another
We use a floating point number when we need high precision in calculations
Double is more fast to be compiled than a float number
Char contains only one character
String is a class that contain a sequence of characters
+ is addition for numbers and concatenation for String
Immutable means you cannot change a String after is created
i++ means incrementing by 1
x-=y same with x=x-y
x*=y same x=x*y

Control Flow

The if-then statement is the most basic of all control flow statements. It tells your program to execute a certain
section of a code, only if a particular test evaluates to true. this is known as a Conditional Logic"
!= means not equal
&& evaluate if the both test are true
|| evaluate if one of both test are true
! logical Not operator known as Logical Complement operator
Operand1 ? Operand2 : Operand3, evaluate Operand1 if it's true will execute Operand 2and
if it's false will execute Operand3

Inheritance

a class could be described as :
    a special block code that contains methods
An object is called an instance of particular class
Class can be organized into logical groups, which are called packages
A "public class" means any other class in any package could access this class. "public" is modifier
A "class" means that class it's accessible only to classes from same package
A "private class" means no other class could access this class
A "protected class" allows classes in same package and any subclasses in other package, to have access to member
Encapsulation means:-bundling of behaviour and attributes on a single object
                    - hiding fields,and some methods, from public access
null is a special keyword in Java, meaning that the variable or attribute has a type but no reference to an object
getter is a method on a class, that retrieves the values of a private field, and returns it
setter is a method in a class, that sets the value of a private field
"this" really refers to is instance that was created when objects was instantiated
Constructor is used in the creation on a object, that's an instance of a class
it's a special type of code block that has a specific name and parameters, much like a method.
Have the same name as class but no return any values.Never include a return type from constructor, not even "void".

Inheritance "IS A" relationship

Constructor chaining is when a constructor explicitly call another overloaded constructor
You can call a constructor only from another constructor

Static variable aka "static member variables"  declared by using word "static". Could be used soring counters,
 generate unique ID, storing a constant value that doesn't change like Pi

 Instance variable, aka fields, don't use "static" and belong to a specific instance of a class

 Static methods are declared using "static" and can't access instance methods and instant variables directly
 and are used for operations which don't require any data from instance of a class.
 Static method are called ClassName.methodName() or methodName() only if in the same class

 Instance methods belong to an instance, class
 To use it have to use "new"

 Plain old java Object (POJO) is a class that have only instance fields. it's used to house data , and pass data,
 between functional classes
 Annotation is a type of metadata and is a way formally describing additional information about our code
 An overridden method is a special method in java, that other class can implement,if they use a specified method signature

"extend" specify the superclass of the class we are declaring.
a class could specify only one class in "extend"
super() is a lot like this(), calls a constructor on the superclass, directly from the subclass constructor.
Like this() have to be first statement of the constructor.
Because of that super() and this() couldn't be called from same constructor
overridden method of a subclass can do one of the three thing:
-it can implement completely different behaviour, overriding behaviour of parent
-simply can call the parent class's parent method, which is implicit
-or the method can call the parent's class method, and can include other code to run, so can extend behaviour of
 parent class
 JVM will run the "lowest" method, from subclass to parent class.
 "public" variables and methods of a superclass could be used by subclass, "private" couldn't be used by subclass
 Constructor from subclass call constructor from superclass

Overloading method:
In a single class, could be used in a child class
have same name
have different parameters
may have different return parameters
may have different access modifiers(private, protected, public)
may throw different exceptions

Overriding method
used to override a behaviour which child class has inherited from parent class
always in two classes parent-child
must have same name and same parameters
must have same return type or covariant return
must not have a lower modifier but may have a higher modifier
must no throw a new or broader checked exception

in String:
\t- insert a tab character
\n- insert a new line character
\"- insert a double quote character
\\- insert a backslash character
""" mark start or end a text block


Composition

it is "HAS A"
relationship

ArrayList

The ArrayList is a class, that really maintains an array in memory, that's actually bigger than what we need,
in most cases.
It keeps track of the capacity, which is the actual size of the array in memory.
But it also keeps track of the elements that've been assigned or set, which is the size of the ArrayList.
As elements are added to an ArrayList, its capacity may need to grow.  This all happens automatically, behind the scenes.
This is why the ArrayList is resizeable.
An ArrayList should be declared, with the type of element in the ArrayList, in angle brackets.
We can use the diamond operator, when creating a new instance in a declaration statement.
You should use a specific type, rather than just the Object class, because Java can then perform compile-time
 type checking

LinkedList

An ArrayList is implemented on top of an array, but a LinkedList is a doubly linked list.
Both implement all of List's methods, but the LinkedList also implements the Queue and Stack methods as well.
Iterator is situated between list's elements. Can use hasNext() or hasPrevious() to checked if remains elements
to be processed

Autoboxing
assign a primitive to a wrapper variable means boxing. If we let java to do it, this is autoboxing
Opposite is autounboxing

Enum type

The enum type is Java's type to support something called an enumeration.
A special data type that contains predefined constants.

Abstraction

An abstract method has a method signature, and a return type, but doesn't have a method body.
Because of this, we say an abstract method is unimplemented.
an abstract class contain an abstract method
A concrete method has a method body, usually with at least one statement.
This means it has operational code, that gets executed, under the right conditions.
A concrete method is said to implement an abstract method, if it overrides one.
Abstract classes and interfaces, can have a mix of abstract and concrete methods.



An interface is similar to an abstract class, although it isn't a class at all.

public interface F…
public class A… implements F….

It's a special type, that's more like a contract between the class and client code, that the compiler enforces.
By declaring it's using an interface, your class must implement all the abstract methods, on the interface.
If we omit an access modifier on a class member, it's implicitly package private.
If we omit an access modifier on an interface member, it's implicitly public.
Changing the access modifier of a method to protected, on an interface, is a compiler error, whether the method is
 concrete or abstract.
Only a concrete method can have private access.
When we use the final modifier, we prevent any further modifications to that component.
•a final method means it can't be overridden by a subclass.
•a final field means an object's field can't be reassigned or given a different value, after its initialization.
•a final static field is a class field that can't be reassigned, or given a different value, after the class's
initialization process.
•a final class can't be overridden, meaning no class can use it, in the extends clause.
•a final variable, in a block of code, means that once it's assigned a value, any remaining code in the block can't
change it.
A constant in Java is a variable that can't be changed.
A constant variable is a final variable of primitive type, or type String, that is initialized with a constant expression .
An extension method is identified by the modifier default, so it's more commonly known as the default method.
This method is a concrete method, meaning it has a code block, and we can add statements to it.
So like overriding a method on a class, you have three choices, when you override a default method on an interface.
•You can choose not to override it at all.
•You can override the method and write code for it, so that the interface method isn't executed.
•Or you can write your own code, and invoke the method on the interface, as part of your implementation.
Static methods don't need to specify a public access modifier, because it's implied.
When you call a public static method on an interface, you must use the interface name as a qualifier.
A private static method can be accessed by either a public static method, a default method, or a private non-static method.
A private non-static method is used to support default methods, and other private methods.
Abstract classes are very similar to interfaces. You can't instantiate either of them. Both types may contain a mix of
 methods declared with, or without a method block.
With abstract classes, you can declare fields that aren't static and final, instance fields in other words.
Also with abstract classes, you can use any of the four access modifiers for its concrete methods.
You can also use all but the private access modifier, for its abstract methods.
An abstract class can extend only one parent class, but it can implement multiple interfaces.
When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods
 in its parent class.
However, if it doesn't, then the subclass must also be declared abstract.

Use Abstract when...
You want to share code, among several closely related classes (Animal for example, with fields, name, age...).
You expect classes that extend your abstract class, to have many common methods or fields, or require access modifiers
 other than public.
You want to declare non-static or non-final fields (for example, name, age), so this enables you to define methods,
that can access and modify the state of an object (getName, setName).
You have a requirement for your base class, to provide a default implementation of certain methods, but other methods
should be open to being overridden by child classes.
Summary: An abstract class provides a common definition, as a base class, that multiple, derived classes can share.

You can't instantiate interfaces, but they may contain a mix of methods declared with, or without an implementation.
All methods on interfaces, declared without a method body, are automatically public and abstract.
An interface can extend another interface.
Interfaces are more flexible, and can deal with a lot more stress on the design of your program, because they aren't
part of the class hierarchy.
A best practice way of coding, is commonly called Coding to an Interface.
By introducing interfaces into your program, you're really introducing points of variation, at which you can plug in
 different implementations for that interface.
Summary: The interface decouples the "what", from the "how", and is used to make different types, behave in similar ways.
Since Java 8, interfaces can now contain default methods, so in other words methods with implementation. The keyword
default is used mostly for backwards compatibility. Public static methods were also introduced in Java 8.
Since Java 9, an interface can also contain private methods, commonly used when default methods share common code.
Use an Interface when...
You expect that unrelated classes will implement your interface.  For example, two of Java's own interfaces,
Comparable and Cloneable, can be implemented by many unrelated classes.
You want to specify the behavior of a particular data type, but you're not concerned about who implements its behavior.
You want to separate different behavior.

Generics
class Team<T>{
private T field;
}
For the generic class, the field's type is that placeholder, just T, and this means it can be any type at all.
The T in the angle brackets means it's the same type as the T, specified as the type of the field.
Now, using T is just a convention, short for whatever type you want to use this Team class for.
But you can put anything you want in there.
Single letter types are the convention however, and they're a lot easier to spot in the class code, so let me encourage
you to stick to this convention.

could be multiple type:
class Team<T1,T2,T3>{

}
But again convention says, that instead of using type parameters like this, it's easier to read the code with alternate
letter selections.
And these are usually S, U, and V, in that order.
If we had three types, we'd probably want to declare this class as shown here, with T, S, and U.
class Team<T,S,U>{

}

A few letters are reserved for special use cases.
The most commonly used type parameter identifiers are:
E for Element (used extensively by the Java Collections Framework).
K for Key (used for mapped types).
N for Number.
T for Type.
V for Value.
S, U, V etc. for 2nd, 3rd, 4th types.

class Team<T extends Player>{

}
This isn't saying our type T extends Player, although it could.
This is saying the parameterized type T, has to be a Player, or a subtype of Player.
Now Player in this case could have been either a class or an interface, the syntax would be the same.
This declaration establishes what is called an upper bound, on the types that are allowed to be used with this class
An upper bound permits access to the bounded type's functionality.
An upper bound limits the kind of type parameters you can use when using a generic class.  The type used must be equal
 to, or a subtype of the bounded type.

Lambda expression

(parameter1, parameter2,...)->expression;
The lambda expression parameters are determined by the associated interface's method, the functional method.
A functional interface is an interface that has one, and only one, abstract method.
This is how Java can infer the method, to derive the parameters and return type, for the lambda expression.
You may also see this referred to as SAM, which is short for Single Abstract Method, which is called the functional method.
A functional interface is the target type for a lambda expression.
The functional interface is the framework that lets a lambda expression be used.
Lambda expressions are also called lambdas for short.
Many of Java's classes, use functional interfaces in their method signatures, which allows us to pass lambdas as
arguments to them.
element->System.out.println(element);

(String element)->System.out.println(element);

(var element)->{
code block
}

Many of the stream operations take functional interfaces as parameters, meaning we can code them with lambda expressions.
(a,b)->a+b
 Parentheses are always required. Explicit types are not.

(Integer a, Integer b)->a+b
If you use an explicit type for one parameter, you must use explicit types for all the parameters.

(var a, var b)->a+b
If you use var for one parameter, you must use var for all parameters.

(a,b)->a+b
when not using curly braces, the return keyword is unnecessary, and will throw a compiler error.

(a, b)->{
var c=a+b;
return c;
}
If you use a statement block, meaning you use the curly braces, a return is required.

The Four basic categories of Functional Interfaces in java.util.function package
Consumer    void accept(T t)    execute code without returning data
Function    R apply(T t)        return a result of an operation or function
Predicate   boolean test(T t)   test if a condition is true or false
Supplier    T get()             return an instance of something

BiConsumer void accept(T t, U u)

Collection

A collection is just an object that represents a group of objects.
The Collection interface is the root of the collection hierarchy.
Like most roots in software hierarchies, it's an abstract representation of the behavior you'd need, for managing a
group of objects.
Remember, the interface let's us describe objects by what they can do, rather than what they really look like, or how
they're ultimately constructed.

A QUEUE is a collection designed for holding elements prior to processing, in other words the processing order matters,
so the first and last positions, or the head and tail, are prioritized.

A SET is a collection conceptually based off of a mathematical set.

A MAP is a collection that stores key and value pairs.
 The keys are a set, and the values are a separate collection, where the key keeps a reference to a value.
 Keys need to be unique, but values don't.
 Elements in a tree are stored in a key value Node, also called an Entry.

It's important to understand that the Collections class is not the Collections Framework.
The framework contains many interfaces and implemented classes, as well as helper classes, which this
Collections class is just one example

Hash Code

HashSet and HashMap, are based on the hash codes of objects.
A hash code can be any valid integer, so it could be one of 4.2 billion valid numbers.
A hashing mechanism will take an integer hash code, and a capacity declaration which specifies the number of buckets
to distribute the objects over.
It then translates the range of hash codes into a range of bucket identifiers.
Hashed implementations use a combination of the hash code and other means, to provide the most efficient bucketing
system, to achieve this desired uniform distribution of the objects.
Objects can be considered equal in other instances as well, if their attribute values are equal, for example.
The String class overrides this method, so that it compares all the characters in each String, to confirm that
two Strings are equal.
Objects that are considered equal should produce the same hashCode.

The Set
A Set is not implicitly ordered.
A Set contains no duplicates.
A Set may contain a single null element.
Sets can be useful because operations on them are very fast.
The set interface defines the basic methods add, remove and clear, to maintain the items in the set.
We can also check if a specific item is in the set using the contains method.
Interestingly enough, there's no way to retrieve an item from a set.
You can check if something exists, using contains, and you can iterate over all the elements in the set, but attempting
to get the 10th element, for example, from a set isn't possible, with a single method.

The HashSet class

When you're trying to understand data in multiple sets, you might want to get the data that's in all the sets,
that's in every set, or the data where there's no overlap.
The collection interface's bulk operations (addAll, retainAll, removeAll, and containAll) can be used to perform these
set operations.
If you need an ordered set, you'll want to consider either the LinkedHashSet or the TreeSet.
A LinkedHashSet maintains the insertion order of the elements.
The TreeSet is a sorted collection, sorted by the natural order of the elements, or by specifying the sort during the
creation of the set.
The LinkedHashSet extends the HashSet class.
The iteration order is therefore the same as the insertion order of the elements, meaning the order is predictable.
All the methods for the LinkedHashSet are the same as those for the HashSet.
A TreeSet's class, uses a data structure that's a derivative of what's called a binary search tree, or Btree for short,
which is based on the concept and efficiencies of the binary search
As elements are added to a TreeSet, they're organized in the form of a tree, where the top of the tree represents that
mid point of the elements.
Further binary divisions become nodes under that.
The left node and its children are elements that are less than the parent node.
The right node and its children are elements that are greater than the parent node.
Instead of looking through all the elements in the collection to locate a match, this allows the tree to be
quickly traversed, each node a simple decision point.
The main point is the tree remains balanced as elements are added.
Elements which implement Comparable (said to have a natural order sort, like Strings and numbers) can be elements
of a TreeSet.
If your elements don't implement Comparable, you must pass a Comparator to the constructor.
The TreeSet does offer many advantages, in terms of built-in functionality over the other two Set implementations,
but it does come at a higher cost.
If your number of elements is not large, or you want a collection that's sorted, and continuously re-sorted as you
add and remove elements, and that shouldn't contain duplicate elements, the TreeSet is a good alternative to the ArrayList.

HashMap

A Java Map can't contain duplicate keys.
Each key can only map to a single value.
The HashMap is unordered, the LinkedHashMap is ordered by insertion order, and the TreeMap is a sorted map.


View

The view, or view collection as Java calls it, doesn't store elements, but depends on a backing collection that stores
the data elements.
We know a map has keys, and these can't contain duplicates.
Each key value pair is stored as an instance of an Entry, and the combination of the key and value will be unique,
because the key is unique.
A Set view of these entries, or nodes in the case of the HashMap, can be retrieved from the method entrySet.
You can use the methods remove, removeAll, retainAll, and clear.
It does not support the add or addAll operations.

The Map interface has the LinkedHashMap and TreeMap classes.
The LinkedHashMap is a key value entry collection, whose keys are ordered by insertion order.
The TreeMap is sorted by it's keys, so a key needs to implement Comparable, or be initialized,
with a specified Comparator.


EnumSet and EnumMap

You can use any List, Set, or Map, with an enum constant.
The EnumSet, and EnumMap, each has a special implementation that differs from the HashSet or HashMap.
These implementations make these two types extremely compact and efficient.
There's no special list implementation for enum types
The EnumSet is a specialized Set implementation for use with enum values.
All of the elements in an EnumSet must come from a single enum type.
The EnumSet is abstract, meaning we can't instantiate it directly.
It comes with many factory methods to create instances.
In general, this set has much better performance than using a HashSet, with an enum type.
Bulk operations (such as containsAll and retainAll) should run very quickly, in constant time, O(1), if they're run
on an enumSet, and their argument is an EnumSet.
The Enum Map is a specialized Map implementation for use with enum type keys.
The keys must all come from the same enum type, and they're ordered naturally by the ordinal value of the enum constants.
This map has the same functionality as a HashMap, with O(1) for basic operations.
The enum key type is specified during construction of the EnumMap, either explicitly by passing the key type's class,
or implicitly by passing another EnumSet.
In general, this map has better performance than using a HashMap, with an enum type.

Two Types of EnumSet implementations

Enum sets are represented internally as bit vectors, which is just a series of ones and zeros.
A one indicates that the enum constant (with an ordinal value that is equal to the index of the bit) is in the set.
A zero indicates the enum constant is not in the set.
Using a bit vector allows all set operations to use bit math, which makes it very fast.
A RegularEnumSet uses a single long as its bit vector, which means it can contain a maximum of 64 bits, representing
64 enum values.
A JumboEnumSet gets returned if you have more than 64 enums.

Mutable vs Immutable

Objects have state, which is the data stored in instance fields.
State can change after an object is created, either intentionally or unintentionally.
When state remains constant throughout the lifetime of the object, and code is prevented from changing the state,
this object is called an immutable object.
An immutable object is an object whose internal state remains constant.
A mutable object is an object whose internal state does not remain constant.
An immutable object isn't subject to unwanted, unplanned and unintended modifications, known as side-effects.
An immutable class is inherently thread-safe, because no threads at all can change it, once it's been constructed.
This allows us to use more efficient collections and operations, which don't have to manage synchronization of access
to this object.
These are two of the most important advantages.
An immutable object can’t be modified after it's been created.

The final modifier in Java

When we use the final modifier, we prevent any further modifications to thatcomponent.
A final method means it can't be overridden by a subclass.
A final field means an object's field can't be reassigned or given a different value, after its initialization.
A final static field is a class field that can't be reassigned, or given a different value, after the class's
initialization process. A field declared on an Interface is always public, static and final.
A final class can't be overridden, meaning no class can use it, in the extends clause.
A final variable, in a block of code, means that once it's assigned a value, any remaining code in the block
can't change it.
A final method parameter means, we can't assign a different value to that parameter in the method code block.
When we use the final modifier, we prevent any further modifications to that component.
A final method means it can't be overridden by a subclass.
A final field means an object's field can't be reassigned or given a different value, after its initialization.
A final static field is a class field that can't be reassigned, or given a different value, after the class's
 initialization process. A field declared on an Interface is always public, static and final.
A final variable, in a block of code, means that once it's assigned a value, any remaining code in the block can't change it.
A final method parameter means, we can't assign a different value to that parameter in the method code block.
You can use the final modifier on methods.
Using final with methods only makes sense in the context of wanting to restrict what your subclasses can override or hide.
Using final on an instance method means subclasses can't override it.
Using final on a class (static) method means subclasses can't hide it.

Immutable Object

An immutable object doesn't change state, once it's created.
An immutable object is a secure object, meaning calling code can't maliciously or mistakenly alter it.
An immutable object simplifies concurrency design.

Strategies for Declaring a Class, to produce immutable objects
This slide describes the strategies of creating a class, that when used, produces immutable objects.
Make instance fields private and final.
Do not define any setter methods.
Create defensive copies in any getters.
Use a constructor or factory method to set data, making copies of mutable reference data.
Mark the class final, or make all constructors private.


The instance initializer block
An instance initializer is a block of code declared directly in a class body.
This code gets executed when an instance of the class is created.
Instance initializers are executed, before any code in class constructors is executed.
You can have multiple initializer blocks.
They will be executed in the order they are declared.

Static Initializers
A static initializer is called the first time a class is referenced or constructed.
A class can have any number of static initialization blocks.
They can be declared anywhere in the class body.
They're called in the order they appear in the source code.
You might use this to set up some environment data or log information, that's related to the class before it can be used.
Remember, this will get executed only during the class's construction and not each instance's construction.

Record Constructors come in three flavors

The Canonical, or Long constructor is the implicitly generated constructor.  You can explicitly declare your own, which
means the implicit one won't get generated.  If you do declare your own, you must make sure fields all get assigned
a value.
The Custom constructor is just an overloaded constructor.  It must explicitly call the canonical constructor as
it's first statement.
The Compact, or Short constructor is a special kind of constructor, used only on records.   It's a succinct way of
explicitly declaring a canonical constructor.
The compact constructor:
You can't have both a compact constructor and an explicit canonical constructor.
This constructor is declared with no parentheses, so no arguments.
It has access to all the arguments of the canonical constructor. Don't confuse the arguments with the instance fields!
You can't do assignments to the instance fields in this constructor.
The implicit canonical constructor's assignments occur after the execution of this code.

The Java Class File Disassembler:
This is javap.
It lists class members, by default just public and protected members in the class file.
This helps us 'see' implicit code in the compiled class file.

Final Classes
Using the final keyword on a class means it can't be extended.
You declare a class final if its definition is complete, and no subclasses are desired or required.
Enums and Records are final classes.
Subclasses can take advantage of mutable fields on parent classes, if the parent classes aren't implementing
defensive code.
One of the easiest ways to prevent this, is to make your class final.
The final and abstract modifiers are incompatible and wouldn't be used in the same declaration.
You can see that if you don't want your class to be instantiated, you can either make it abstract or use a more
 restrictive access modifier on the class.

 Sealed Classes
This modifier can be used for both outer types and nested types.
When used, a permits clause is also required in most cases, which lists the allowed subclasses.
Subclasses can be nested classes, classes declared in the same file, classes in the same package, or if using Java's
modules, in the same module.
What this means though, for this specific conversation, is that all our code so far, since JDK9, is part of what's
called, the unnamed default module.
Because of this, I can't use subclasses in the permits clause that are in other packages.
A sealed class and its direct subclasses create a circular reference.
Using the sealed keyword, requires the parent class to declare it's subclasses, using a permits clause.
This means the parent class has to know about every direct subclass, and these have to exist, in the same package
in this case.
In addition, the sealed keyword puts a requirement on all the subclasses that were declared in the permits clause.
It requires each subclass to declare one of the three valid modifiers for a class extending a sealed class.
These are final, sealed or non-sealed.
All subclasses declared in the permits clause, must be declared as final, sealed or non-sealed.
Declaring a class final, means no other subclasses can extend that class, as I show with class A, on this slide.
A subclass declared with a sealed modifier, shown here with class B, must in turn use a permits clause.
Its subclasses in turn, have to use one of the three valid modifiers.
Lastly, a subclass can use the non-sealed modifier, as shown with class C.
This means it's basically unsealing itself for all it's subclasses.

Unmodifiable Collections are NOT immutable collections

They become immutable collections, if the elements in the collections themselves are fully immutable.
They are collections with limited functionality that can help us minimize mutability.
You can't remove, add or clear elements from an immutable collection.
You also can't replace or sort elements.
Mutator methods will throw an UnsupportedOperationException.
You can't create this type of collection with nulls.

Stream

A sequence of elements supporting sequential and parallel aggregate operations.
Streams are a mechanism for describing a whole series of processes, before actually executing them.
The stream and the collection types were designed for different purposes.
A collection is used to store and manage a series of elements in Java, providing direct access to the Collection elements.
You can use collections to manipulate or query a set of data.
There's nothing you can do with a stream, that you couldn't already do with a Collection.
However, a stream was designed to manage the processing of elements.
Streams don’t actually store elements, instead these elements are computed on demand, from a data providing source.
When you call many of the methods on a stream, execution may not immediately occur.
Instead, you'll need to invoke a special operation on the stream, like you would by calling a lambda's functional method.
This special operation is called a terminal operation.
Streams are an exciting addition to Java, because they provide several benefits.
First, they make the code to process data uniform, concise and repeatable, in ways that feel similar to a database's
structured query language (SQL).
Second, when working with large collections, parallel streams will provide a performance advantage.
All of the code samples I've provided up to this point, using collections, will continue to be valuable for many use cases.
It's time to talk about this new way of doing things, using this additional functional programming feature.
This entire chain of operations is what's called a Stream Pipeline.
The source of the stream is where the data elements are coming from.
In our example, it's coming from a list, bingoPool.
All pipelines start with a stream, so in this example, we need to call the stream method on the bingoPool
list to get a stream.
There are a lot of other kinds of sources, and ways to create new streams, including infinite streams
Stream Pipelines end in a terminal operation.
A terminal operation is required.
Everything else, between the source and the terminal operation is an intermediate operation
An intermediate operation is not required.
You can have a pipeline that just has a source and terminal operation, and these are quite common.
Every intermediate operation processes elements on the stream, and returns a stream as a result.
You can't reuse a stream.
Stream Types May Change As the Pipeline Process Progresses
Terminal Operation on Stream:
Now it's time to see why stream processes are such a welcome feature, as I show you other terminal operations we can use.
Some are designed to find matches, most of which are targets for a Predicate lambda expression.
Some are designed to transform stream data into a collection, or some other reference type.
Others aggregate information, to count elements, or find a minimum or maximum value, and don't take arguments.
A reduction operation is a special type of terminal operation.
Stream elements are processed, to produce a single output.
The result can be a primitive type, like a long, in the case of the count operation.
The result can be a reference type, like Optional or one of the Statistics types I'll be covering shortly.
It can also be any type of your choice, such as an array, a list, or some other type.
The primitive streams have average and sum as well, and a summaryStatistics operation which gives you count, min, max,
average and sum in one result.
A reduction operation is a special type of terminal operation.
Stream elements are processed, to produce a single output.
The result can be a primitive type, like a long, in the case of the count operation.
The result can be a reference type, like Optional or one of the Statistics types I'll be covering shortly.
It can also be any type of your choice, such as an array, a list, or some other type.
I can use terminal operations to return information about the aggregated data set.
There are three terminal operations that let you get an overall sense, of what your stream elements contain, based on
some specified condition.
These all return a boolean, and take a Predicate as an argument.
You can think of these as ways to ask true or false questions about the data set, the stream, as a whole.

BigDecimal

The BigDecimal class stores a floating point number in two integer fields.
The first field holds an unscaled value, with a type of BigInteger, another class in the java.math package,
that can store numbers bigger than even long values.
The second field is the scale, which can be positive, 0 or negative.
A positive or 0 scale defines how many digits in the unscaled value, are after the decimal point.
You can use a negative scale as well, which means the unscaled value is multiplied by ten to the power of the
negation of the scale.

Regular expression

A regular expression is simply text.
It may contain characters or character combinations that have special meaning.
These are called metacharacters.
These combinations are interpreted by a regular expression pattern processor.
Most patterns you'll need, have already been written, and you'll find these, with an internet search.
They are big time-savers!
You don't have to write a lot of looping and parsing code.
You can use a regular expression to do this work, with just a couple of lines of code.
There are really good reasons to use regular expressions.
Verify something is formatted correctly.
Find occurrences of patterns in text.
Replace matching occurrences of patterns in text.
Extract matching occurrences from the text.
Split your text by a pattern.
A regular expression can be made up of combinations of the following:
Literals. These have no additional meaning and are a one to one match. If you specify the literal "abc", the code will
 match on the first occurrence of "abc", in your string.
Character Classes. Some of these are predefined, others you can define yourself. The period or dot is an example of
 a predefined character class.
Quantifiers. These metacharacters identify the number of occurrences of a character class or literal, required to make
a match. I used the asterisk, but there are several others I'll review shortly.
Boundary matchers, or anchors. These specify the position in the text, for example at the start of the text or the end.
Groups. These identify and allow for the capturing of subexpressions.

What does it mean to Compile a Regular Expression?

The string containing the expression is passed to the compile method, of a Pattern class, which returns a Pattern instance.
This string, the regular expression, is said to be compiled into a Pattern, by Java's regular expression processor.
This compilation process consists of
Checking the string for syntactical correctness.
Building an internal representation, a decision tree made up of nodes, and boolean decision points, derived from the
various parts of the regular expression.
Optimizing the pattern, by simplifying the expression and eliminating redundancies.  This process increases the
 efficiency of matching the expression to character sequences.
By compiling regular expressions into Pattern objects, you benefit from improved performance and code efficiency,
 on subsequent matching.
The compiled pattern can be reused across multiple matching operations, saving computational resources,
and reducing processing time.

Matcher class advantages
In addition to matching on the entire input, Matcher offers two other operations for partial matching.
These methods are lookingAt, and overloaded versions of the find method.
Matcher supports capturing groups and access to the text within the group.
Matcher can be reused for multiple match operations on different String inputs, meaning the pattern
 doesn't have to be recompiled.
 An instance of a Matcher class has state, which changes as operations are performed on it.
 This means the Matcher class is not thread safe.
 It also means state may need to be reset, before a new String is evaluated.
Greedy regular expressions match as many characters as possible.
The expression .*, which is a greedy expression, matches any number of characters, including the empty string.
Reluctant regular expressions, on the other hand, match as few characters as possible from the input text.
The regular expression .*? matches any number of characters, but stops at the earliest successful point, where the
 overall pattern is matched.
The default type of regular expression is greedy.
You can use the ? to be a quantifier modifier, making the regular expression reluctant.



Input/Output

Checked Exception
A Checked Exception must be caught, or specified in the containing method's throws clause
How do you handle a checked exception?
You have two options.
You can wrap the statement that throws a checked exception, in a try catch block, and then handle the situation in the catch block.
Or, alternately, you can change the method signature, declaring a throws clause, and specifying this exception type.
LBYL stands for, "Look Before You Leap".  This style of coding involves checking for errors, before you perform
an operation.
EAFP stands for, "Easier to Ask Forgiveness than Permission".  This assumes an operation will usually succeed,
and then handles any errors that occur, if they do occur.

NIO2 file operations:
The NIO2 types include support for:
Asynchronous file I/O operations.
File locking, including more granular locking.  This means, instead of locking the entire file, a region of it can be locked.
File metadata retrieval.
Symbolic link manipulation.
File system notifications. This means changes occurring on a path, can be made watchable to registered services.
NIO2 types are non-blocking, meaning asynchronous access to resources, by multiple threads, is supported.
They manage memory more efficiently, reading and writing files directly to and from memory into buffers, through something called a FileChannel.
You can also read from or write to multiple buffers in a single operation.









*/



