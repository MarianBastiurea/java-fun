/*
General Information

JDK means Java Development Kit
JVM means Java Virtual Machine
Statement is complete command to be executed
Keyword is any one of a number of reserved word, that have a predefined meaning in Java
Keywords need to be in lowercase
Variables are a way to store information in computer

Expression

Expression- computes to a single value
Statements- Stand alone units of work
Whitespace- spaces around code ignored by Java and it's purpose for human readability
Reformat code- change code format to be more easy to read
Declaration Statement is used to define a variable by indicating the data type, name and eventually set a value
Expression is a coding construct, that evaluates a single value
Expression is a code segment in Right side of equals sign in assign or declaration statement
Class is a building blocks for object-oriented programming
Overflow and Underflow is a value larger or lower than maximum or minimum value of an int, double,etc.
A numeric literal that exceeds maximum value of int should have "L" as suffix.
Cannot declare variables with different data type in a single statement
If you declare multiple variables with same data type, you have to declare data types only once before any variables name
The Java compiler does not attempt to evaluate the value in a variable when it's used in a calculation, so it's
doesn't know if the value fits, and throws an error
Casting means to convert a number from one type to another
We use a floating point number when we need high precision in calculations
Double is more fast to be compiled than a float number
Char contains only one character
String is a class that contain a sequence of characters
+ is addition for numbers and concatenation for String
Immutable means you cannot change a String after is created
i++ means incrementing by 1
x-=y same with x=x-y
x*=y same x=x*y

Control Flow

The if-then statement is the most basic of all control flow statements. It tells your program to execute a certain
section of a code, only if a particular test evaluates to true. this is known as a Conditional Logic"
!= means not equal
&& evaluate if the both test are true
|| evaluate if one of both test are true
! logical Not operator known as Logical Complement operator
Operand1 ? Operand2 : Operand3, evaluate Operand1 if it's true will execute Operand 2and
if it's false will execute Operand3

Inheritance

a class could be described as :
    a special block code that contains methods
An object is called an instance of particular class
Class can be organized into logical groups, which are called packages
A "public class" means any other class in any package could access this class. "public" is modifier
A "class" means that class it's accessible only to classes from same package
A "private class" means no other class could access this class
A "protected class" allows classes in same package and any subclasses in other package, to have access to member
Encapsulation means:-bundling of behaviour and attributes on a single object
                    - hiding fields,and some methods, from public access
null is a special keyword in Java, meaning that the variable or attribute has a type but no reference to an object
getter is a method on a class, that retrieves the values of a private field, and returns it
setter is a method in a class, that sets the value of a private field
"this" really refers to is instance that was created when objects was instantiated
Constructor is used in the creation on a object, that's an instance of a class
it's a special type of code block that has a specific name and parameters, much like a method.
Have the same name as class but no return any values.Never include a return type from constructor, not even "void".

Inheritance "IS A" relationship

Constructor chaining is when a constructor explicitly call another overloaded constructor
You can call a constructor only from another constructor

Static variable aka "static member variables"  declared by using word "static". Could be used soring counters,
 generate unique ID, storing a constant value that doesn't change like Pi

 Instance variable, aka fields, don't use "static" and belong to a specific instance of a class

 Static methods are declared using "static" and can't access instance methods and instant variables directly
 and are used for operations which don't require any data from instance of a class.
 Static method are called ClassName.methodName() or methodName() only if in the same class

 Instance methods belong to an instance, class
 To use it have to use "new"

 Plain old java Object (POJO) is a class that have only instance fields. it's used to house data , and pass data,
 between functional classes
 Annotation is a type of metadata and is a way formally describing additional information about our code
 An overridden method is a special method in java, that other class can implement,if they use a specified method signature

"extend" specify the superclass of the class we are declaring.
a class could specify only one class in "extend"
super() is a lot like this(), calls a constructor on the superclass, directly from the subclass constructor.
Like this() have to be first statement of the constructor.
Because of that super() and this() couldn't be called from same constructor
overridden method of a subclass can do one of the three thing:
-it can implement completely different behaviour, overriding behaviour of parent
-simply can call the parent class's parent method, which is implicit
-or the method can call the parent's class method, and can include other code to run, so can extend behaviour of
 parent class
 JVM will run the "lowest" method, from subclass to parent class.
 "public" variables and methods of a superclass could be used by subclass, "private" couldn't be used by subclass
 Constructor from subclass call constructor from superclass

Overloading method:
In a single class, could be used in a child class
have same name
have different parameters
may have different return parameters
may have different access modifiers(private, protected, public)
may throw different exceptions

Overriding method
used to override a behaviour which child class has inherited from parent class
always in two classes parent-child
must have same name and same parameters
must have same return type or covariant return
must not have a lower modifier but may have a higher modifier
must no throw a new or broader checked exception

in String:
\t- insert a tab character
\n- insert a new line character
\"- insert a double quote character
\\- insert a backslash character
""" mark start or end a text block


Composition

it is "HAS A"
relationship

ArrayList

The ArrayList is a class, that really maintains an array in memory, that's actually bigger than what we need,
in most cases.
It keeps track of the capacity, which is the actual size of the array in memory.
But it also keeps track of the elements that've been assigned or set, which is the size of the ArrayList.
As elements are added to an ArrayList, its capacity may need to grow.  This all happens automatically, behind the scenes.
This is why the ArrayList is resizeable.
An ArrayList should be declared, with the type of element in the ArrayList, in angle brackets.
We can use the diamond operator, when creating a new instance in a declaration statement.
You should use a specific type, rather than just the Object class, because Java can then perform compile-time
 type checking

LinkedList

An ArrayList is implemented on top of an array, but a LinkedList is a doubly linked list.
Both implement all of List's methods, but the LinkedList also implements the Queue and Stack methods as well.
Iterator is situated between list's elements. Can use hasNext() or hasPrevious() to checked if remains elements
to be processed

Autoboxing
assign a primitive to a wrapper variable means boxing. If we let java to do it, this is autoboxing
Opposite is autounboxing

Enum type

The enum type is Java's type to support something called an enumeration.
A special data type that contains predefined constants.

Abstraction

An abstract method has a method signature, and a return type, but doesn't have a method body.
Because of this, we say an abstract method is unimplemented.
an abstract class contain an abstract method
A concrete method has a method body, usually with at least one statement.
This means it has operational code, that gets executed, under the right conditions.
A concrete method is said to implement an abstract method, if it overrides one.
Abstract classes and interfaces, can have a mix of abstract and concrete methods.



An interface is similar to an abstract class, although it isn't a class at all.

public interface F…
public class A… implements F….

It's a special type, that's more like a contract between the class and client code, that the compiler enforces.
By declaring it's using an interface, your class must implement all the abstract methods, on the interface.
If we omit an access modifier on a class member, it's implicitly package private.
If we omit an access modifier on an interface member, it's implicitly public.
Changing the access modifier of a method to protected, on an interface, is a compiler error, whether the method is
 concrete or abstract.
Only a concrete method can have private access.
When we use the final modifier, we prevent any further modifications to that component.
•a final method means it can't be overridden by a subclass.
•a final field means an object's field can't be reassigned or given a different value, after its initialization.
•a final static field is a class field that can't be reassigned, or given a different value, after the class's
initialization process.
•a final class can't be overridden, meaning no class can use it, in the extends clause.
•a final variable, in a block of code, means that once it's assigned a value, any remaining code in the block can't
change it.
A constant in Java is a variable that can't be changed.
A constant variable is a final variable of primitive type, or type String, that is initialized with a constant expression .
An extension method is identified by the modifier default, so it's more commonly known as the default method.
This method is a concrete method, meaning it has a code block, and we can add statements to it.
So like overriding a method on a class, you have three choices, when you override a default method on an interface.
•You can choose not to override it at all.
•You can override the method and write code for it, so that the interface method isn't executed.
•Or you can write your own code, and invoke the method on the interface, as part of your implementation.
Static methods don't need to specify a public access modifier, because it's implied.
When you call a public static method on an interface, you must use the interface name as a qualifier.
A private static method can be accessed by either a public static method, a default method, or a private non-static method.
A private non-static method is used to support default methods, and other private methods.
Abstract classes are very similar to interfaces. You can't instantiate either of them. Both types may contain a mix of
 methods declared with, or without a method block.
With abstract classes, you can declare fields that aren't static and final, instance fields in other words.
Also with abstract classes, you can use any of the four access modifiers for its concrete methods.
You can also use all but the private access modifier, for its abstract methods.
An abstract class can extend only one parent class, but it can implement multiple interfaces.
When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods
 in its parent class.
However, if it doesn't, then the subclass must also be declared abstract.

Use Abstract when...
You want to share code, among several closely related classes (Animal for example, with fields, name, age...).
You expect classes that extend your abstract class, to have many common methods or fields, or require access modifiers
 other than public.
You want to declare non-static or non-final fields (for example, name, age), so this enables you to define methods,
that can access and modify the state of an object (getName, setName).
You have a requirement for your base class, to provide a default implementation of certain methods, but other methods
should be open to being overridden by child classes.
Summary: An abstract class provides a common definition, as a base class, that multiple, derived classes can share.

You can't instantiate interfaces, but they may contain a mix of methods declared with, or without an implementation.
All methods on interfaces, declared without a method body, are automatically public and abstract.
An interface can extend another interface.
Interfaces are more flexible, and can deal with a lot more stress on the design of your program, because they aren't
part of the class hierarchy.
A best practice way of coding, is commonly called Coding to an Interface.
By introducing interfaces into your program, you're really introducing points of variation, at which you can plug in
 different implementations for that interface.
Summary: The interface decouples the "what", from the "how", and is used to make different types, behave in similar ways.
Since Java 8, interfaces can now contain default methods, so in other words methods with implementation. The keyword
default is used mostly for backwards compatibility. Public static methods were also introduced in Java 8.
Since Java 9, an interface can also contain private methods, commonly used when default methods share common code.
Use an Interface when...
You expect that unrelated classes will implement your interface.  For example, two of Java's own interfaces,
Comparable and Cloneable, can be implemented by many unrelated classes.
You want to specify the behavior of a particular data type, but you're not concerned about who implements its behavior.
You want to separate different behavior.

Generics
class Team<T>{
private T field;
}
For the generic class, the field's type is that placeholder, just T, and this means it can be any type at all.
The T in the angle brackets means it's the same type as the T, specified as the type of the field.
Now, using T is just a convention, short for whatever type you want to use this Team class for.
But you can put anything you want in there.
Single letter types are the convention however, and they're a lot easier to spot in the class code, so let me encourage
you to stick to this convention.

could be multiple type:
class Team<T1,T2,T3>{

}
But again convention says, that instead of using type parameters like this, it's easier to read the code with alternate
letter selections.
And these are usually S, U, and V, in that order.
If we had three types, we'd probably want to declare this class as shown here, with T, S, and U.
class Team<T,S,U>{

}

A few letters are reserved for special use cases.
The most commonly used type parameter identifiers are:
E for Element (used extensively by the Java Collections Framework).
K for Key (used for mapped types).
N for Number.
T for Type.
V for Value.
S, U, V etc. for 2nd, 3rd, 4th types.

class Team<T extends Player>{

}
This isn't saying our type T extends Player, although it could.
This is saying the parameterized type T, has to be a Player, or a subtype of Player.
Now Player in this case could have been either a class or an interface, the syntax would be the same.
This declaration establishes what is called an upper bound, on the types that are allowed to be used with this class
An upper bound permits access to the bounded type's functionality.
An upper bound limits the kind of type parameters you can use when using a generic class.  The type used must be equal
 to, or a subtype of the bounded type.

Lambda expression

(parameter1, parameter2,...)->expression;
The lambda expression parameters are determined by the associated interface's method, the functional method.
A functional interface is an interface that has one, and only one, abstract method.
This is how Java can infer the method, to derive the parameters and return type, for the lambda expression.
You may also see this referred to as SAM, which is short for Single Abstract Method, which is called the functional method.
A functional interface is the target type for a lambda expression.
The functional interface is the framework that lets a lambda expression be used.
Lambda expressions are also called lambdas for short.
Many of Java's classes, use functional interfaces in their method signatures, which allows us to pass lambdas as
arguments to them.
element->System.out.println(element);

(String element)->System.out.println(element);

(var element)->{
code block
}

Many of the stream operations take functional interfaces as parameters, meaning we can code them with lambda expressions.
(a,b)->a+b
 Parentheses are always required. Explicit types are not.

(Integer a, Integer b)->a+b
If you use an explicit type for one parameter, you must use explicit types for all the parameters.

(var a, var b)->a+b
If you use var for one parameter, you must use var for all parameters.

(a,b)->a+b
when not using curly braces, the return keyword is unnecessary, and will throw a compiler error.

(a, b)->{
var c=a+b;
return c;
}
If you use a statement block, meaning you use the curly braces, a return is required.

The Four basic categories of Functional Interfaces in java.util.function package
Consumer    void accept(T t)    execute code without returning data
Function    R apply(T t)        return a result of an operation or function
Predicate   boolean test(T t)   test if a condition is true or false
Supplier    T get()             return an instance of something

BiConsumer void accept(T t, U u)

Collection

A collection is just an object that represents a group of objects.
The Collection interface is the root of the collection hierarchy.
Like most roots in software hierarchies, it's an abstract representation of the behavior you'd need, for managing a
group of objects.
Remember, the interface let's us describe objects by what they can do, rather than what they really look like, or how
they're ultimately constructed.

A QUEUE is a collection designed for holding elements prior to processing, in other words the processing order matters,
so the first and last positions, or the head and tail, are prioritized.

A SET is a collection conceptually based off of a mathematical set.

A MAP is a collection that stores key and value pairs.
 The keys are a set, and the values are a separate collection, where the key keeps a reference to a value.
 Keys need to be unique, but values don't.
 Elements in a tree are stored in a key value Node, also called an Entry.

It's important to understand that the Collections class is not the Collections Framework.
The framework contains many interfaces and implemented classes, as well as helper classes, which this
Collections class is just one example

Hash Code

HashSet and HashMap, are based on the hash codes of objects.
A hash code can be any valid integer, so it could be one of 4.2 billion valid numbers.
A hashing mechanism will take an integer hash code, and a capacity declaration which specifies the number of buckets
to distribute the objects over.
It then translates the range of hash codes into a range of bucket identifiers.
Hashed implementations use a combination of the hash code and other means, to provide the most efficient bucketing
system, to achieve this desired uniform distribution of the objects.
Objects can be considered equal in other instances as well, if their attribute values are equal, for example.
The String class overrides this method, so that it compares all the characters in each String, to confirm that
two Strings are equal.
Objects that are considered equal should produce the same hashCode.

The Set
A Set is not implicitly ordered.
A Set contains no duplicates.
A Set may contain a single null element.
Sets can be useful because operations on them are very fast.
The set interface defines the basic methods add, remove and clear, to maintain the items in the set.
We can also check if a specific item is in the set using the contains method.
Interestingly enough, there's no way to retrieve an item from a set.
You can check if something exists, using contains, and you can iterate over all the elements in the set, but attempting
to get the 10th element, for example, from a set isn't possible, with a single method.

The HashSet class

When you're trying to understand data in multiple sets, you might want to get the data that's in all the sets,
that's in every set, or the data where there's no overlap.
The collection interface's bulk operations (addAll, retainAll, removeAll, and containAll) can be used to perform these
set operations.
If you need an ordered set, you'll want to consider either the LinkedHashSet or the TreeSet.
A LinkedHashSet maintains the insertion order of the elements.
The TreeSet is a sorted collection, sorted by the natural order of the elements, or by specifying the sort during the
creation of the set.
The LinkedHashSet extends the HashSet class.
The iteration order is therefore the same as the insertion order of the elements, meaning the order is predictable.
All the methods for the LinkedHashSet are the same as those for the HashSet.
A TreeSet's class, uses a data structure that's a derivative of what's called a binary search tree, or Btree for short,
which is based on the concept and efficiencies of the binary search
As elements are added to a TreeSet, they're organized in the form of a tree, where the top of the tree represents that
mid point of the elements.
Further binary divisions become nodes under that.
The left node and its children are elements that are less than the parent node.
The right node and its children are elements that are greater than the parent node.
Instead of looking through all the elements in the collection to locate a match, this allows the tree to be
quickly traversed, each node a simple decision point.
The main point is the tree remains balanced as elements are added.
Elements which implement Comparable (said to have a natural order sort, like Strings and numbers) can be elements
of a TreeSet.
If your elements don't implement Comparable, you must pass a Comparator to the constructor.
The TreeSet does offer many advantages, in terms of built-in functionality over the other two Set implementations,
but it does come at a higher cost.
If your number of elements is not large, or you want a collection that's sorted, and continuously re-sorted as you
add and remove elements, and that shouldn't contain duplicate elements, the TreeSet is a good alternative to the ArrayList.

HashMap

A Java Map can't contain duplicate keys.
Each key can only map to a single value.
The HashMap is unordered, the LinkedHashMap is ordered by insertion order, and the TreeMap is a sorted map.


View

The view, or view collection as Java calls it, doesn't store elements, but depends on a backing collection that stores
the data elements.
We know a map has keys, and these can't contain duplicates.
Each key value pair is stored as an instance of an Entry, and the combination of the key and value will be unique,
because the key is unique.
A Set view of these entries, or nodes in the case of the HashMap, can be retrieved from the method entrySet.
You can use the methods remove, removeAll, retainAll, and clear.
It does not support the add or addAll operations.

The Map interface has the LinkedHashMap and TreeMap classes.
The LinkedHashMap is a key value entry collection, whose keys are ordered by insertion order.
The TreeMap is sorted by it's keys, so a key needs to implement Comparable, or be initialized,
with a specified Comparator.


EnumSet and EnumMap

You can use any List, Set, or Map, with an enum constant.
The EnumSet, and EnumMap, each has a special implementation that differs from the HashSet or HashMap.
These implementations make these two types extremely compact and efficient.
There's no special list implementation for enum types
The EnumSet is a specialized Set implementation for use with enum values.
All of the elements in an EnumSet must come from a single enum type.
The EnumSet is abstract, meaning we can't instantiate it directly.
It comes with many factory methods to create instances.
In general, this set has much better performance than using a HashSet, with an enum type.
Bulk operations (such as containsAll and retainAll) should run very quickly, in constant time, O(1), if they're run
on an enumSet, and their argument is an EnumSet.
The Enum Map is a specialized Map implementation for use with enum type keys.
The keys must all come from the same enum type, and they're ordered naturally by the ordinal value of the enum constants.
This map has the same functionality as a HashMap, with O(1) for basic operations.
The enum key type is specified during construction of the EnumMap, either explicitly by passing the key type's class,
or implicitly by passing another EnumSet.
In general, this map has better performance than using a HashMap, with an enum type.

Two Types of EnumSet implementations

Enum sets are represented internally as bit vectors, which is just a series of ones and zeros.
A one indicates that the enum constant (with an ordinal value that is equal to the index of the bit) is in the set.
A zero indicates the enum constant is not in the set.
Using a bit vector allows all set operations to use bit math, which makes it very fast.
A RegularEnumSet uses a single long as its bit vector, which means it can contain a maximum of 64 bits, representing
64 enum values.
A JumboEnumSet gets returned if you have more than 64 enums.

Mutable vs Immutable

Objects have state, which is the data stored in instance fields.
State can change after an object is created, either intentionally or unintentionally.
When state remains constant throughout the lifetime of the object, and code is prevented from changing the state,
this object is called an immutable object.
An immutable object is an object whose internal state remains constant.
A mutable object is an object whose internal state does not remain constant.
An immutable object isn't subject to unwanted, unplanned and unintended modifications, known as side-effects.
An immutable class is inherently thread-safe, because no threads at all can change it, once it's been constructed.
This allows us to use more efficient collections and operations, which don't have to manage synchronization of access
to this object.
These are two of the most important advantages.
An immutable object can’t be modified after it's been created.

The final modifier in Java

When we use the final modifier, we prevent any further modifications to thatcomponent.
A final method means it can't be overridden by a subclass.
A final field means an object's field can't be reassigned or given a different value, after its initialization.
A final static field is a class field that can't be reassigned, or given a different value, after the class's
initialization process. A field declared on an Interface is always public, static and final.
A final class can't be overridden, meaning no class can use it, in the extends clause.
A final variable, in a block of code, means that once it's assigned a value, any remaining code in the block
can't change it.
A final method parameter means, we can't assign a different value to that parameter in the method code block.
When we use the final modifier, we prevent any further modifications to that component.
A final method means it can't be overridden by a subclass.
A final field means an object's field can't be reassigned or given a different value, after its initialization.
A final static field is a class field that can't be reassigned, or given a different value, after the class's
 initialization process. A field declared on an Interface is always public, static and final.
A final variable, in a block of code, means that once it's assigned a value, any remaining code in the block can't change it.
A final method parameter means, we can't assign a different value to that parameter in the method code block.
You can use the final modifier on methods.
Using final with methods only makes sense in the context of wanting to restrict what your subclasses can override or hide.
Using final on an instance method means subclasses can't override it.
Using final on a class (static) method means subclasses can't hide it.

Immutable Object

An immutable object doesn't change state, once it's created.
An immutable object is a secure object, meaning calling code can't maliciously or mistakenly alter it.
An immutable object simplifies concurrency design.

Strategies for Declaring a Class, to produce immutable objects
This slide describes the strategies of creating a class, that when used, produces immutable objects.
Make instance fields private and final.
Do not define any setter methods.
Create defensive copies in any getters.
Use a constructor or factory method to set data, making copies of mutable reference data.
Mark the class final, or make all constructors private.


The instance initializer block
An instance initializer is a block of code declared directly in a class body.
This code gets executed when an instance of the class is created.
Instance initializers are executed, before any code in class constructors is executed.
You can have multiple initializer blocks.
They will be executed in the order they are declared.

Static Initializers
A static initializer is called the first time a class is referenced or constructed.
A class can have any number of static initialization blocks.
They can be declared anywhere in the class body.
They're called in the order they appear in the source code.
You might use this to set up some environment data or log information, that's related to the class before it can be used.
Remember, this will get executed only during the class's construction and not each instance's construction.

Record Constructors come in three flavors

The Canonical, or Long constructor is the implicitly generated constructor.  You can explicitly declare your own, which
means the implicit one won't get generated.  If you do declare your own, you must make sure fields all get assigned
a value.
The Custom constructor is just an overloaded constructor.  It must explicitly call the canonical constructor as
it's first statement.
The Compact, or Short constructor is a special kind of constructor, used only on records.   It's a succinct way of
explicitly declaring a canonical constructor.
The compact constructor:
You can't have both a compact constructor and an explicit canonical constructor.
This constructor is declared with no parentheses, so no arguments.
It has access to all the arguments of the canonical constructor. Don't confuse the arguments with the instance fields!
You can't do assignments to the instance fields in this constructor.
The implicit canonical constructor's assignments occur after the execution of this code.

The Java Class File Disassembler:
This is javap.
It lists class members, by default just public and protected members in the class file.
This helps us 'see' implicit code in the compiled class file.

Final Classes
Using the final keyword on a class means it can't be extended.
You declare a class final if its definition is complete, and no subclasses are desired or required.
Enums and Records are final classes.
Subclasses can take advantage of mutable fields on parent classes, if the parent classes aren't implementing
defensive code.
One of the easiest ways to prevent this, is to make your class final.
The final and abstract modifiers are incompatible and wouldn't be used in the same declaration.
You can see that if you don't want your class to be instantiated, you can either make it abstract or use a more
 restrictive access modifier on the class.

 Sealed Classes
This modifier can be used for both outer types and nested types.
When used, a permits clause is also required in most cases, which lists the allowed subclasses.
Subclasses can be nested classes, classes declared in the same file, classes in the same package, or if using Java's
modules, in the same module.
What this means though, for this specific conversation, is that all our code so far, since JDK9, is part of what's
called, the unnamed default module.
Because of this, I can't use subclasses in the permits clause that are in other packages.
A sealed class and its direct subclasses create a circular reference.
Using the sealed keyword, requires the parent class to declare it's subclasses, using a permits clause.
This means the parent class has to know about every direct subclass, and these have to exist, in the same package
in this case.
In addition, the sealed keyword puts a requirement on all the subclasses that were declared in the permits clause.
It requires each subclass to declare one of the three valid modifiers for a class extending a sealed class.
These are final, sealed or non-sealed.
All subclasses declared in the permits clause, must be declared as final, sealed or non-sealed.
Declaring a class final, means no other subclasses can extend that class, as I show with class A, on this slide.
A subclass declared with a sealed modifier, shown here with class B, must in turn use a permits clause.
Its subclasses in turn, have to use one of the three valid modifiers.
Lastly, a subclass can use the non-sealed modifier, as shown with class C.
This means it's basically unsealing itself for all it's subclasses.

Unmodifiable Collections are NOT immutable collections

They become immutable collections, if the elements in the collections themselves are fully immutable.
They are collections with limited functionality that can help us minimize mutability.
You can't remove, add or clear elements from an immutable collection.
You also can't replace or sort elements.
Mutator methods will throw an UnsupportedOperationException.
You can't create this type of collection with nulls.

Stream

A sequence of elements supporting sequential and parallel aggregate operations.
Streams are a mechanism for describing a whole series of processes, before actually executing them.
The stream and the collection types were designed for different purposes.
A collection is used to store and manage a series of elements in Java, providing direct access to the Collection elements.
You can use collections to manipulate or query a set of data.
There's nothing you can do with a stream, that you couldn't already do with a Collection.
However, a stream was designed to manage the processing of elements.
Streams don’t actually store elements, instead these elements are computed on demand, from a data providing source.
When you call many of the methods on a stream, execution may not immediately occur.
Instead, you'll need to invoke a special operation on the stream, like you would by calling a lambda's functional method.
This special operation is called a terminal operation.
Streams are an exciting addition to Java, because they provide several benefits.
First, they make the code to process data uniform, concise and repeatable, in ways that feel similar to a database's
structured query language (SQL).
Second, when working with large collections, parallel streams will provide a performance advantage.
All of the code samples I've provided up to this point, using collections, will continue to be valuable for many use cases.
It's time to talk about this new way of doing things, using this additional functional programming feature.
This entire chain of operations is what's called a Stream Pipeline.
The source of the stream is where the data elements are coming from.
In our example, it's coming from a list, bingoPool.
All pipelines start with a stream, so in this example, we need to call the stream method on the bingoPool
list to get a stream.
There are a lot of other kinds of sources, and ways to create new streams, including infinite streams
Stream Pipelines end in a terminal operation.
A terminal operation is required.
Everything else, between the source and the terminal operation is an intermediate operation
An intermediate operation is not required.
You can have a pipeline that just has a source and terminal operation, and these are quite common.
Every intermediate operation processes elements on the stream, and returns a stream as a result.
You can't reuse a stream.
Stream Types May Change As the Pipeline Process Progresses
Terminal Operation on Stream:
Now it's time to see why stream processes are such a welcome feature, as I show you other terminal operations we can use.
Some are designed to find matches, most of which are targets for a Predicate lambda expression.
Some are designed to transform stream data into a collection, or some other reference type.
Others aggregate information, to count elements, or find a minimum or maximum value, and don't take arguments.
A reduction operation is a special type of terminal operation.
Stream elements are processed, to produce a single output.
The result can be a primitive type, like a long, in the case of the count operation.
The result can be a reference type, like Optional or one of the Statistics types I'll be covering shortly.
It can also be any type of your choice, such as an array, a list, or some other type.
The primitive streams have average and sum as well, and a summaryStatistics operation which gives you count, min, max,
average and sum in one result.
A reduction operation is a special type of terminal operation.
Stream elements are processed, to produce a single output.
The result can be a primitive type, like a long, in the case of the count operation.
The result can be a reference type, like Optional or one of the Statistics types I'll be covering shortly.
It can also be any type of your choice, such as an array, a list, or some other type.
I can use terminal operations to return information about the aggregated data set.
There are three terminal operations that let you get an overall sense, of what your stream elements contain, based on
some specified condition.
These all return a boolean, and take a Predicate as an argument.
You can think of these as ways to ask true or false questions about the data set, the stream, as a whole.

BigDecimal

The BigDecimal class stores a floating point number in two integer fields.
The first field holds an unscaled value, with a type of BigInteger, another class in the java.math package,
that can store numbers bigger than even long values.
The second field is the scale, which can be positive, 0 or negative.
A positive or 0 scale defines how many digits in the unscaled value, are after the decimal point.
You can use a negative scale as well, which means the unscaled value is multiplied by ten to the power of the
negation of the scale.

Regular expression

A regular expression is simply text.
It may contain characters or character combinations that have special meaning.
These are called metacharacters.
These combinations are interpreted by a regular expression pattern processor.
Most patterns you'll need, have already been written, and you'll find these, with an internet search.
They are big time-savers!
You don't have to write a lot of looping and parsing code.
You can use a regular expression to do this work, with just a couple of lines of code.
There are really good reasons to use regular expressions.
Verify something is formatted correctly.
Find occurrences of patterns in text.
Replace matching occurrences of patterns in text.
Extract matching occurrences from the text.
Split your text by a pattern.
A regular expression can be made up of combinations of the following:
Literals. These have no additional meaning and are a one to one match. If you specify the literal "abc", the code will
 match on the first occurrence of "abc", in your string.
Character Classes. Some of these are predefined, others you can define yourself. The period or dot is an example of
 a predefined character class.
Quantifiers. These metacharacters identify the number of occurrences of a character class or literal, required to make
a match. I used the asterisk, but there are several others I'll review shortly.
Boundary matchers, or anchors. These specify the position in the text, for example at the start of the text or the end.
Groups. These identify and allow for the capturing of subexpressions.

What does it mean to Compile a Regular Expression?

The string containing the expression is passed to the compile method, of a Pattern class, which returns a Pattern instance.
This string, the regular expression, is said to be compiled into a Pattern, by Java's regular expression processor.
This compilation process consists of
Checking the string for syntactical correctness.
Building an internal representation, a decision tree made up of nodes, and boolean decision points, derived from the
various parts of the regular expression.
Optimizing the pattern, by simplifying the expression and eliminating redundancies.  This process increases the
 efficiency of matching the expression to character sequences.
By compiling regular expressions into Pattern objects, you benefit from improved performance and code efficiency,
 on subsequent matching.
The compiled pattern can be reused across multiple matching operations, saving computational resources,
and reducing processing time.

Matcher class advantages
In addition to matching on the entire input, Matcher offers two other operations for partial matching.
These methods are lookingAt, and overloaded versions of the find method.
Matcher supports capturing groups and access to the text within the group.
Matcher can be reused for multiple match operations on different String inputs, meaning the pattern
 doesn't have to be recompiled.
 An instance of a Matcher class has state, which changes as operations are performed on it.
 This means the Matcher class is not thread safe.
 It also means state may need to be reset, before a new String is evaluated.
Greedy regular expressions match as many characters as possible.
The expression .*, which is a greedy expression, matches any number of characters, including the empty string.
Reluctant regular expressions, on the other hand, match as few characters as possible from the input text.
The regular expression .*? matches any number of characters, but stops at the earliest successful point, where the
 overall pattern is matched.
The default type of regular expression is greedy.
You can use the ? to be a quantifier modifier, making the regular expression reluctant.



Input/Output

Checked Exception
A Checked Exception must be caught, or specified in the containing method's throws clause
How do you handle a checked exception?
You have two options.
You can wrap the statement that throws a checked exception, in a try catch block, and then handle the situation in the catch block.
Or, alternately, you can change the method signature, declaring a throws clause, and specifying this exception type.
LBYL stands for, "Look Before You Leap".  This style of coding involves checking for errors, before you perform
an operation.
EAFP stands for, "Easier to Ask Forgiveness than Permission".  This assumes an operation will usually succeed,
and then handles any errors that occur, if they do occur.

Legacy (io)
The File class and the FileReader class have been part of Java, since version 1.
The FileReader class implements the AutoCloseable interface, through it's parent class, Reader.
This class opens a file resource implicitly.
In contrast, when you create an instance of a File, you aren't actually opening that file.
Instead, you're working with something called a file handler, that lets you perform OS-like operations.
A file handle is a reference to a file that is used by the operating system to keep track of the file.
It is an abstract representation of the file, and it does not contain any of the actual data from the file.
A file resource, on the other hand, is the actual data from the file.
It is stored on the disk, and it can be accessed by the operating system, and by applications.


NIO2 file operations:
The NIO2 types include support for:
Asynchronous file I/O operations.
File locking, including more granular locking.  This means, instead of locking the entire file, a region of it
 can be locked.
File metadata retrieval.
Symbolic link manipulation.
File system notifications. This means changes occurring on a path, can be made watchable to registered services.
NIO2 types are non-blocking, meaning asynchronous access to resources, by multiple threads, is supported.
They manage memory more efficiently, reading and writing files directly to and from memory into buffers, through
something called a FileChannel.
You can also read from or write to multiple buffers in a single operation.

For writing files, there's temporary storage, that gets filled up as writes are executed, on a Writer class.
Physical writes to disk happen when the buffer is flushed.
This is the process of taking the text stored in the buffer, and writing it to the output file, and clearing the
buffer's cache.
The frequency of flushing can be affected by a number of factors, including the size of the buffer, the speed of
 the disk, and the amount of data that's being written to the file.

When you open a RandomAccessFile, it's file pointer is at 0, or the start of the file.

Serialization
The process of translating a data structure or object, into a format that can be stored on a file, is called
serialization.
Only instances of Serializable classes can be serialized, meaning the class must implement the Serializable interface.
This interface doesn't have any methods, it's just used to mark the class as serializable.
All subtypes of a serializable class are themselves also serializable.
The default serialization mechanism, writes the class of the object, the class signature, and the values of non-static
fields.
These elements are used to restore the object, and it's state, during the read operation.
This process is called reconstituting the data, or deserialization.

serialVersionUID
The serialVersionUID field is a runtime field, that the compiler will implicitly create, if it's not explicitly
 declared, for classes that are serializable.
It's based on class details such as the number of fields, their types, and declarations.
When we read an object from a stream, the runtime checks the stored serialVersionUID.
If they don't match, then there's a compatibility problem and the runtime will throw this invalid class exception.

What constitutes an Incompatible Change?
Changing the declared type of a primitive field.
Deleting fields.
Changing a non-static field to static, or a non-transient field to transient.
There are other more complicated changes, such as moving a class within its hierarchy, changing the writeObject
and readObject methods after you've used them to serialize previously, and a few others.

What constitutes a Compatible Change?
The good news is that not all changes you make to your class are going to invalidate the serialization process.
Some changes are compatible changes:
Adding fields.
Adding writeObject and readObject methods.
Changing the access to a field.
Changing a field from static to nonstatic, or transient.
For the full documentation on compatible changes, you can visit the link shown here.

The transient modifier
The transient modifier is used to indicate that a field should not be serialized.
This can be useful for variables that contain sensitive information, or just variables that don't need to be
persisted, for other reasons.

Introduction to Concurrency and Threads

Process is a unit of execution, that has its own memory space.
The terms process and application are often used interchangeably.
Each application has its own memory space, also known as the heap.
The heap isn't shared between two applications or two processes, they each have their own.

A Thread
A thread is a single unit of execution, within a process.
Each process can have multiple threads.
Every application has at least one thread, and that's the main thread.
Our code will run on the main thread.
We can also have our code run in other threads, which we can explicitly create and start.
Threads Share Process Memory
Creating a thread doesn't require as many resources as creating a process does.
Every thread created by a process, shares that process's memory space, the heap.
This can cause big problems with your applications.
Each thread's got what's called a thread stack.
This is memory, that only a single thread, will have access to.
Every Java application runs as a single process, and each process can then have multiple threads within it.
Every process has a heap, and every thread has a thread stack.
Why use multiple threads?
One of the most common reasons, is to offload long running tasks.
Instead of tying up the main thread, we can create additional threads, to execute tasks that might take a long time.
This frees up the main thread so that it can continue working, and executing, and being responsive to the user.
You also might use multiple threads to process large amounts of data, which can improve performance, of data intensive
 operations.
A web server, is another use case for many threads, allowing multiple connections and requests to be handled,
 simultaneously.
Concurrency, refers to an application doing more than one thing at a time.
Concurrency allows different parts of a program to make progress independently, often leading to better resource
utilization, and improved performance.
One task doesn't have to complete, before another one can start, and multiple threads can make incremental progress.
Threads are the fundamental building blocks, to support concurrency, in a Java application.
They're essential, because they allow us to perform multiple tasks simultaneously, within a single process.

Creating a Thread Instance
Extend the Thread class, and create an instance of this new subclass.
Create a new instance of Thread, and pass it any instance that implements the Runnable interface.
 This includes passing a lambda expression.
Use an Executor, to create one or more threads for you.

The difference between executing run and start on a thread:
There's a big difference between calling run() and start().
If you execute the run method, it's executed synchronously, by the running thread it's invoked from.
If you want your code to be run asynchronously, you must call the start method.

The native modifier on a method:
The native modifier indicates that this method's source code isn't written in Java.
It's written in another language, such as C or C++.
The code in this example, is part of a native library, such as a dll file.

Why use a native library?
The reasons to do this include
To access system-level functionality that's platform-specific.
To interface with hardware.
To optimize performance for tasks that might be computationally-intensive.

Runnable is a Functional Interface:
It's important to recognize that Runnable is a functional interface.
It's functional method, or its single access method, is the run method.
Anywhere you see a Runnable type, it's a target for a lambda expression.
You can have any class implement the Runnable interface to run asynchronously.

Advantages of Extending Thread:
You have more control over the thread's behavior and properties.
You can access the thread's methods and fields directly from your sub class.
You can create a new thread for each task.

Disadvantages of Extending Thread:
You can only extend one class in Java, so your subclass can't extend any other classes.
Your class is tightly coupled to the Thread class, which may make it difficult to maintain.

Advantages of Implementing a Runnable and creating a Thread instance with it:
You can extend any class and still implement Runnable.
Your class (if you create a class) is loosely coupled to the Thread class, which makes it easier to maintain.
You can use anonymous classes, lambda expressions, or method references, to very quickly describe thread behavior.

Disadvantages of Implementing a Runnable and creating a Thread instance with it:
You do have less control over the thread's behavior and properties.
In other words, You can't access the thread's methods and fields directly, from the run method.


Synchronized Methods
Different invocations of synchronized methods, on the same object, are guaranteed not to interleave.
When one thread is executing a synchronized method for an object, all other threads that invoke synchronized
methods for the same object, block, and suspend their execution, until the first thread is done with the object.
When a synchronized method exits, it ensures that the state of the object is visible to all threads.

Critical Section
The critical section is the code that's referencing a shared resource like a variable.
Only one thread at a time should be able to execute a critical section.
When all critical sections are synchronized, the class is thread safe.

The Object instance monitor
Every object instance in Java has a built-in intrinsic lock, also known as a monitor lock.
A thread acquires a lock by executing a synchronized method on the instance, or by using the instance as the parameter
 to a synchronized statement.
A thread releases a lock when it exits from a synchronized block or method, even if it throws an exception.
Only one thread at a time can acquire this lock, which prevents all other threads from accessing the instance's state,
until the lock is released.
All other threads, which want access to the instance's state  through synchronized code, will block, and wait, until
they can acquire a lock.

Reentrant Synchronization
I said that once a thread acquires a lock, all other threads will block, which also require that lock.
Because these method calls are executed from the same thread, any nested calls which try to acquire the lock,
won't block, because the current thread already has it.
This feature is called Reentrant Synchronization.
Without this, threads could block indefinitely.
This concept is built into the Java language, and it's based on the monitor mechanism.

Producer Consumer Application
This kind of application has a class that produces data, so the Producer.
It also has a class that reads the data, or consumes it in some way, this is the Consumer.
=======
Threads accessing memory:
Each thread has its own stack for local variables and method calls.
One thread doesn't have access to another thread's stack.
Every concurrent thread additionally has access to the process memory, or the heap.
This shared memory space allows all threads, to read and modify the same objects.
When one thread changes an object on the heap, these changes are visible to other threads.

Time Slicing:
Time slicing is also known as time-sharing or time division.
It's a technique used in multitasking operating systems, to allow multiple threads or processes to share a single CPU for execution.
Available CPU time is sliced into small time intervals, which are divvied out to the threads.
Each thread gets that interval, to attempt to make some progress, on the tasks it has to do.
Whether it completes its task or not, in that time slice, doesn't matter to the thread management system.
When the time is up, it has to yield to another thread, and wait until its turn again.
Unfortunately, when your threads are sharing heap memory, things can change during that wait.

The Java Memory Model, is a specification that defines some rules and behaviors for threads, to help control
and manage shared access to data, and operations.
Atomicity of Operations. Few operations are truly atomic.
Synchronization is the process of controlling threads' access to shared resources.

Interference
This means another active thread has an open door, to that same unit of work, where the paused thread is
only partially done.
When threads start and pause, in the same blocks as other threads, this is called interleaving.

Interleaving
When multiple threads run concurrently, their instructions can overlap or interleave in time.
The execution of multiple threads happens in an arbitrary order.
The order in which the threads execute can't be guaranteed.

Atomic actions
In programming, an atomic action is one, that effectively happens all at once.
An atomic action either happens completely, or it doesn't happen at all.
Side effects of an atomic action are never visible until the action completes.

Thread-Safe
An object or a block of code is thread safe, if it isn't compromised, by the execution of concurrent threads.
This means, the correctness and consistency of the program's output or its visible state, is unaffected by other threads.
Atomic operations and immutable objects are examples of thread-safe code.

Memory Consistency Errors
The operating system may read from heap variables, and make a copy of the value, in each thread's own storage cache.
Each thread has its own small and fast memory storage, that holds its own copy of a shared resource's value.
One thread can modify a shared variable, but this change might not be immediately reflected or visible.
Instead, it's first updated in the thread's local cache.
The operating system may not flush the first thread's changes to the heap, until the thread has finished executing.

volatile
The volatile keyword is used as a modifier for class variables.
It's an indicator that this variable's value may be changed by multiple threads.
This modifier ensures that the variable is always read from, and written to the main memory, rather than from any thread-specific caches.
This provides memory consistency for this variable's value across threads.
Volatile has limited usage though.

When to use volatile
There are specific scenarios when you'll want to use volatile.
When a variable is used to track the state of a shared resource, such as a counter or a flag.
When a variable is used to communicate between threads.

When NOT to use volatile
When a variable is only used by a single thread.
When a variable is used to store a large amount of data.






The Object instance monitor
Every object instance in Java has a built-in intrinsic lock, also known as a monitor lock.
A thread acquires a lock by executing a synchronized method on the instance, or by using the instance as the parameter
to a synchronized statement.
A thread releases a lock when it exits from a synchronized block or method, even if it throws an exception.
Only one thread at a time can acquire this lock, which prevents all other threads from accessing the instance's state,
until the lock is released.
All other threads, which want access to the instance's state  through synchronized code, will block, and wait, until
they can acquire a lock.

The synchronized statement can be applied to a more granular code block
The synchronized statement is usually a better option in most circumstances, since it limits the scope of
 synchronization, to the critical section of code.
In other words, it gives you much more granular control, over when you want other threads to block.
The synchronized block can use a different object, on which to acquire its lock.
This means that code, accessing this bank account instance, wouldn't have to block entirely.

Reentrant Synchronization
I said that once a thread acquires a lock, all other threads will block, which also require that lock.
Because these method calls are executed from the same thread, any nested calls which try to acquire the lock,
won't block, because the current thread already has it.
This feature is called Reentrant Synchronization.
Without this, threads could block indefinitely.
This concept is built into the Java language, and it's based on the monitor mechanism.

Producer Consumer Application
This kind of application has a class that produces data, so the Producer.
It also has a class that reads the data, or consumes it in some way, this is the Consumer.
The threads are stuck, one spinning indefinitely, the other blocked from doing anything.
This is a classic deadlock situation.

The Object class's wait, notify and notifyAll methods
The wait, notify, and notifyAll methods, are used to manage some monitor lock situations, to prevent threads from
blocking indefinitely.
Because these methods are on Object, any instance of any class, can execute these methods, from within a synchronized
method or statement.

The Purpose of a Lock
The purpose of a lock is to control access to a shared resource by multiple threads.

Limitations of the Monitor Lock
The monitor lock is pretty easy to use, but it does have limitations.
There's no way to test if the intrinsic lock has already been acquired.
There's no way to interrupt a blocked thread.
There's not an easy way to debug, or examine the intrinsic lock.
The intrinsic lock is an exclusive lock.

Lock Hold Count
The hold count of a lock counts the number of times that a single thread, the owner of the lock, has acquired the lock.
When a thread acquires a lock for the first time, the lock's hold count is set to one.
If a lock is re-entrant, and a thread, reacquires the same lock, the lock's hold count will get incremented.
When a thread releases a lock, the lock's hold count is decremented.
A lock is only released when it's hold count becomes zero.
Because of this, it's really important to include a call to the unlock method in a finally clause, of any code
that will acquire a lock, even if it's re-entrant.

Review of the Advantages of using Lock implementations
Explicit Control over when to acquire and release locks, making it easier to avoid deadlocks, and manage other
concurrency challenges.
Timeouts allow you to attempt to acquire a lock without blocking indefinitely.
Along with timeouts, Interruptible Locking lets you handle interruptions during acquisition more gracefully.
Improved Debugging methods let you query the number of waiting threads, and check if a thread holds a lock.


Managing Threads
These are the ExecutorService classes, and they exist to manage the creation and execution of threads.

Managing Individual Threads
When using a Thread class, you have rudimentary control over that thread.
You can interrupt a thread, and join it to another thread.
You can name the thread, try to prioritize it, and start each manually, one at a time.
You can also pass it an UncaughtExceptionHandler, to deal with exceptions that happen in a thread.
Managing threads manually can be complex and error-prone.
It can lead to complex issues like resource contention, thread creation overhead, and scalability challenges.
For these reasons, you'll want to use an ExecutorService, even when working with a single thread.

Benefits of Managing Threads with an Implementation of ExecutorService
The ExecutorService type in Java is an interface. Java provides several implementations of this type which provide
the following benefits:
Simplify thread management, by abstracting execution, to the level of tasks which need to be run.
Use Thread Pools, reducing the cost of creating new threads.
Efficient Scaling, by utilizing multiple processor cores.
Built-in synchronization, reducing concurrency-related errors.
Graceful Shutdown, preventing resource leaks.
Scheduled implementations exist to further help with management workflows.

Advantages of using an ExecutorService
The job of managing threads is simplified.
ExecutorService implementations let you stay focused on tasks that need to be run, rather than thread creation
and management.

Creating Threads is Expensive
Creating threads, destroying threads, and then creating them again can be expensive.
A thread pool mitigates the cost, by keeping a set of threads around, in a pool, for current and future work.
Threads, once they complete one task, can then be reassigned to another task, without the expense of destroying
that thread and creating a new one.

The Mechanics of a Thread Pool
A thread pool consists of three components.
Worker Threads are available in a pool to execute tasks. They're pre-created and kept alive, throughout the
 lifetime of the application.
Submitted Tasks are placed in a First-In First-Out queue.  Threads pop tasks from the queue, and execute them,
so they're executed in the order they're submitted.
The Thread Pool Manager allocates tasks to threads, and ensures proper thread synchronization.

Difference between Runnable and Callable

Significantly, Callable returns a value.
This means you can get data back from your running threads.

The Future Interface

A Future represents a result, of an asynchronous computation.
It's a generic type, a placeholder for a result instance.
It has methods that cancel the task, retrieve the result, or check if the computation was completed or cancelled.
The get method returns the result, but you can only call this get method, when the computation is complete,
otherwise the call will block, until it does complete.
The overloaded version of the get method allows you to specify a wait time, rather than blocking.


Work Stealing Thread Pool
The work stealing thread pool is used for parallelism, and concurrent execution of tasks.
Each worker thread has its own task queue.
When a worker thread finishes its own tasks, and its queue is empty, it can "steal" tasks from the back of other
worker threads' queues.
This helps to balance the workload among threads, reduces idle time, and optimizes resource usage.

The ForkJoinPool
The ForkJoinPool class is Java's implementation of the Work Stealing Pool.
It's based on the fork-join, or divide and conquer algorithm of computing.
This algorithm
breaks down a complex task into smaller subtasks,
processes them independently and in parallel,
and then combines the results to solve the original problem.

Parallel Streams
Parallel streams allow you to perform operations on collections in parallel, thus potentially speeding up data processing.
The key advantages of parallel streams are:
Improved performance on multi-core CPUs.
Simplified code for concurrent processing.
Automatic workload distribution among available threads.

Why the HashMap isn't thread-safe?
Lacks synchronization.
There are no guarantees of memory consistency, while iterating.

Concurrent Classes vs. Synchronized Wrapper Classes
Both concurrent and synchronized collections are thread-safe, and can be used in parallel streams,
or in a multi-threaded application.
Synchronized collections are implemented using locks which protect the collection from concurrent access.
 This means a single lock is used to synchronize access to the entire map.
Concurrent collections are more efficient than synchronized collections, because they use techniques like
fine-grained locking, or non-blocking algorithms to enable safe concurrent access without the need for heavy handed locking, meaning synchronized or single access locks.
Concurrent collections are recommended over synchronized collections in most scenarios.

Concurrent Collections
LinkedList and ArrayList, as well as TreeSet and HashSet, are also NOT thread-safe.
Each of these can be used with a synchronized wrapper, which you can get from the Collections helper class.
The synchronized wrappers provide a thread-safe option for you, with less impact on the design, if you need
to make existing code work concurrently.
If you're starting with new code though, I'd recommend using  concurrent collections.

Concurrent Collections for Arrays and Lists
For lists, there are two concurrent collection choices, depending on the type of work which needs to be done in parallel.
Use ConcurrentLinkedQueue when you'll have frequent insertions and removals, such as producer-consumer scenarios, or
task scheduling.
Use CopyOnWriteArrayList when you have a read-heavy workload with infrequent modifications. This type of list is useful
 for scenarios like configuration management, or read-only views of data.
For an array, you can use one of the concurrent list options above
Or Use an ArrayBlockingQueue. This is a fixed-size queue, that blocks under two circumstances. The first is if you try
 to poll or remove an element from an empty queue. The second is if you try to offer, or add an element to a full queue.
  This is designed as a First In First Out or FIFO queue.







*/



