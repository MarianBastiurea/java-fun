/*
General Information

JDK means Java Development Kit
JVM means Java Virtual Machine
Statement is complete command to be executed
Keyword is any one of a number of reserved word, that have a predefined meaning in Java
Keywords need to be in lowercase
Variables are a way to store information in computer

Expression

Expression- computes to a single value
Statements- Stand alone units of work
Whitespace- spaces around code ignored by Java and it's purpose for human readability
Reformat code- change code format to be more easy to read
Declaration Statement is used to define a variable by indicating the data type, name and eventually set a value
Expression is a coding construct, that evaluates a single value
Expression is a code segment in Right side of equals sign in assign or declaration statement
Class is a building blocks for object-oriented programming
Overflow and Underflow is a value larger or lower than maximum or minimum value of an int, double,etc.
A numeric literal that exceeds maximum value of int should have "L" as suffix.
Cannot declare variables with different data type in a single statement
If you declare multiple variables with same data type, you have to declare data types only once before any variables name
The Java compiler does not attempt to evaluate the value in a variable when it's used in a calculation, so it's
doesn't know if the value fits, and throws an error
Casting means to convert a number from one type to another
We use a floating point number when we need high precision in calculations
Double is more fast to be compiled than a float number
Char contains only one character
String is a class that contain a sequence of characters
+ is addition for numbers and concatenation for String
Immutable means you cannot change a String after is created
i++ means incrementing by 1
x-=y same with x=x-y
x*=y same x=x*y

Control Flow

The if-then statement is the most basic of all control flow statements. It tells your program to execute a certain
section of a code, only if a particular test evaluates to true. this is known as a Conditional Logic"
!= means not equal
&& evaluate if the both test are true
|| evaluate if one of both test are true
! logical Not operator known as Logical Complement operator
Operand1 ? Operand2 : Operand3, evaluate Operand1 if it's true will execute Operand 2and
if it's false will execute Operand3

Inheritance

a class could be described as :
    a special block code that contains methods
An object is called an instance of particular class
Class can be organized into logical groups, which are called packages
A "public class" means any other class in any package could access this class. "public" is modifier
A "class" means that class it's accessible only to classes from same package
A "private class" means no other class could access this class
A "protected class" allows classes in same package and any subclasses in other package, to have access to member
Encapsulation means:-bundling of behaviour and attributes on a single object
                    - hiding fields,and some methods, from public access
null is a special keyword in Java, meaning that the variable or attribute has a type but no reference to an object
getter is a method on a class, that retrieves the values of a private field, and returns it
setter is a method in a class, that sets the value of a private field
"this" really refers to is instance that was created when objects was instantiated
Constructor is used in the creation on a object, that's an instance of a class
it's a special type of code block that has a specific name and parameters, much like a method.
Have the same name as class but no return any values.Never include a return type from constructor, not even "void".

Inheritance "IS A" relationship

Constructor chaining is when a constructor explicitly call another overloaded constructor
You can call a constructor only from another constructor

Static variable aka "static member variables"  declared by using word "static". Could be used soring counters,
 generate unique ID, storing a constant value that doesn't change like Pi

 Instance variable, aka fields, don't use "static" and belong to a specific instance of a class

 Static methods are declared using "static" and can't access instance methods and instant variables directly
 and are used for operations which don't require any data from instance of a class.
 Static method are called ClassName.methodName() or methodName() only if in the same class

 Instance methods belong to an instance, class
 To use it have to use "new"

 Plain old java Object (POJO) is a class that have only instance fields. it's used to house data , and pass data,
 between functional classes
 Annotation is a type of metadata and is a way formally describing additional information about our code
 An overridden method is a special method in java, that other class can implement,if they use a specified method signature

"extend" specify the superclass of the class we are declaring.
a class could specify only one class in "extend"
super() is a lot like this(), calls a constructor on the superclass, directly from the subclass constructor.
Like this() have to be first statement of the constructor.
Because of that super() and this() couldn't be called from same constructor
overridden method of a subclass can do one of the three thing:
-it can implement completely different behaviour, overriding behaviour of parent
-simply can call the parent class's parent method, which is implicit
-or the method can call the parent's class method, and can include other code to run, so can extend behaviour of
 parent class
 JVM will run the "lowest" method, from subclass to parent class.
 "public" variables and methods of a superclass could be used by subclass, "private" couldn't be used by subclass
 Constructor from subclass call constructor from superclass

Overloading method:
In a single class, could be used in a child class
have same name
have different parameters
may have different return parameters
may have different access modifiers(private, protected, public)
may throw different exceptions

Overriding method
used to override a behaviour which child class has inherited from parent class
always in two classes parent-child
must have same name and same parameters
must have same return type or covariant return
must not have a lower modifier but may have a higher modifier
must no throw a new or broader checked exception

in String:
\t- insert a tab character
\n- insert a new line character
\"- insert a double quote character
\\- insert a backslash character
""" mark start or end a text block


Composition

it is "HAS A"
relationship

ArrayList

The ArrayList is a class, that really maintains an array in memory, that's actually bigger than what we need,
in most cases.
It keeps track of the capacity, which is the actual size of the array in memory.
But it also keeps track of the elements that've been assigned or set, which is the size of the ArrayList.
As elements are added to an ArrayList, its capacity may need to grow.  This all happens automatically, behind the scenes.
This is why the ArrayList is resizeable.
An ArrayList should be declared, with the type of element in the ArrayList, in angle brackets.
We can use the diamond operator, when creating a new instance in a declaration statement.
You should use a specific type, rather than just the Object class, because Java can then perform compile-time
 type checking

LinkedList

An ArrayList is implemented on top of an array, but a LinkedList is a doubly linked list.
Both implement all of List's methods, but the LinkedList also implements the Queue and Stack methods as well.
Iterator is situated between list's elements. Can use hasNext() or hasPrevious() to checked if remains elements
to be processed

Autoboxing
assign a primitive to a wrapper variable means boxing. If we let java to do it, this is autoboxing
Opposite is autounboxing

Enum type

The enum type is Java's type to support something called an enumeration.
A special data type that contains predefined constants.

Abstraction

An abstract method has a method signature, and a return type, but doesn't have a method body.
Because of this, we say an abstract method is unimplemented.
an abstract class contain an abstract method
A concrete method has a method body, usually with at least one statement.
This means it has operational code, that gets executed, under the right conditions.
A concrete method is said to implement an abstract method, if it overrides one.
Abstract classes and interfaces, can have a mix of abstract and concrete methods.



An interface is similar to an abstract class, although it isn't a class at all.

public interface F…
public class A… implements F….

It's a special type, that's more like a contract between the class and client code, that the compiler enforces.
By declaring it's using an interface, your class must implement all the abstract methods, on the interface.
If we omit an access modifier on a class member, it's implicitly package private.
If we omit an access modifier on an interface member, it's implicitly public.
Changing the access modifier of a method to protected, on an interface, is a compiler error, whether the method is
 concrete or abstract.
Only a concrete method can have private access.
When we use the final modifier, we prevent any further modifications to that component.
•a final method means it can't be overridden by a subclass.
•a final field means an object's field can't be reassigned or given a different value, after its initialization.
•a final static field is a class field that can't be reassigned, or given a different value, after the class's
initialization process.
•a final class can't be overridden, meaning no class can use it, in the extends clause.
•a final variable, in a block of code, means that once it's assigned a value, any remaining code in the block can't
change it.
A constant in Java is a variable that can't be changed.
A constant variable is a final variable of primitive type, or type String, that is initialized with a constant expression .
An extension method is identified by the modifier default, so it's more commonly known as the default method.
This method is a concrete method, meaning it has a code block, and we can add statements to it.
So like overriding a method on a class, you have three choices, when you override a default method on an interface.
•You can choose not to override it at all.
•You can override the method and write code for it, so that the interface method isn't executed.
•Or you can write your own code, and invoke the method on the interface, as part of your implementation.
Static methods don't need to specify a public access modifier, because it's implied.
When you call a public static method on an interface, you must use the interface name as a qualifier.
A private static method can be accessed by either a public static method, a default method, or a private non-static method.
A private non-static method is used to support default methods, and other private methods.
Abstract classes are very similar to interfaces. You can't instantiate either of them. Both types may contain a mix of
 methods declared with, or without a method block.
With abstract classes, you can declare fields that aren't static and final, instance fields in other words.
Also with abstract classes, you can use any of the four access modifiers for its concrete methods.
You can also use all but the private access modifier, for its abstract methods.
An abstract class can extend only one parent class, but it can implement multiple interfaces.
When an abstract class is subclassed, the subclass usually provides implementations for all of the abstract methods
 in its parent class.
However, if it doesn't, then the subclass must also be declared abstract.

Use Abstract when...
You want to share code, among several closely related classes (Animal for example, with fields, name, age...).
You expect classes that extend your abstract class, to have many common methods or fields, or require access modifiers
 other than public.
You want to declare non-static or non-final fields (for example, name, age), so this enables you to define methods,
that can access and modify the state of an object (getName, setName).
You have a requirement for your base class, to provide a default implementation of certain methods, but other methods
should be open to being overridden by child classes.
Summary: An abstract class provides a common definition, as a base class, that multiple, derived classes can share.

You can't instantiate interfaces, but they may contain a mix of methods declared with, or without an implementation.
All methods on interfaces, declared without a method body, are automatically public and abstract.
An interface can extend another interface.
Interfaces are more flexible, and can deal with a lot more stress on the design of your program, because they aren't
part of the class hierarchy.
A best practice way of coding, is commonly called Coding to an Interface.
By introducing interfaces into your program, you're really introducing points of variation, at which you can plug in
 different implementations for that interface.
Summary: The interface decouples the "what", from the "how", and is used to make different types, behave in similar ways.
Since Java 8, interfaces can now contain default methods, so in other words methods with implementation. The keyword
default is used mostly for backwards compatibility. Public static methods were also introduced in Java 8.
Since Java 9, an interface can also contain private methods, commonly used when default methods share common code.
Use an Interface when...
You expect that unrelated classes will implement your interface.  For example, two of Java's own interfaces,
Comparable and Cloneable, can be implemented by many unrelated classes.
You want to specify the behavior of a particular data type, but you're not concerned about who implements its behavior.
You want to separate different behavior.

Generics
class Team<T>{
private T field;
}
For the generic class, the field's type is that placeholder, just T, and this means it can be any type at all.
The T in the angle brackets means it's the same type as the T, specified as the type of the field.
Now, using T is just a convention, short for whatever type you want to use this Team class for.
But you can put anything you want in there.
Single letter types are the convention however, and they're a lot easier to spot in the class code, so let me encourage
you to stick to this convention.

could be multiple type:
class Team<T1,T2,T3>{

}
But again convention says, that instead of using type parameters like this, it's easier to read the code with alternate
letter selections.
And these are usually S, U, and V, in that order.
If we had three types, we'd probably want to declare this class as shown here, with T, S, and U.
class Team<T,S,U>{

}

A few letters are reserved for special use cases.
The most commonly used type parameter identifiers are:
E for Element (used extensively by the Java Collections Framework).
K for Key (used for mapped types).
N for Number.
T for Type.
V for Value.
S, U, V etc. for 2nd, 3rd, 4th types.

class Team<T extends Player>{

}
This isn't saying our type T extends Player, although it could.
This is saying the parameterized type T, has to be a Player, or a subtype of Player.
Now Player in this case could have been either a class or an interface, the syntax would be the same.
This declaration establishes what is called an upper bound, on the types that are allowed to be used with this class
An upper bound permits access to the bounded type's functionality.
An upper bound limits the kind of type parameters you can use when using a generic class.  The type used must be equal
 to, or a subtype of the bounded type.

Lambda expression

(parameter1, parameter2,...)->expression;
The lambda expression parameters are determined by the associated interface's method, the functional method.
A functional interface is an interface that has one, and only one, abstract method.
This is how Java can infer the method, to derive the parameters and return type, for the lambda expression.
You may also see this referred to as SAM, which is short for Single Abstract Method, which is called the functional method.
A functional interface is the target type for a lambda expression.
The functional interface is the framework that lets a lambda expression be used.
Lambda expressions are also called lambdas for short.
Many of Java's classes, use functional interfaces in their method signatures, which allows us to pass lambdas as
arguments to them.
element->System.out.println(element);

(String element)->System.out.println(element);

(var element)->{
code block
}

Many of the stream operations take functional interfaces as parameters, meaning we can code them with lambda expressions.
(a,b)->a+b
 Parentheses are always required. Explicit types are not.

(Integer a, Integer b)->a+b
If you use an explicit type for one parameter, you must use explicit types for all the parameters.

(var a, var b)->a+b
If you use var for one parameter, you must use var for all parameters.

(a,b)->a+b
when not using curly braces, the return keyword is unnecessary, and will throw a compiler error.

(a, b)->{
var c=a+b;
return c;
}
If you use a statement block, meaning you use the curly braces, a return is required.

The Four basic categories of Functional Interfaces in java.util.function package
Consumer    void accept(T t)    execute code without returning data
Function    R apply(T t)        return a result of an operation or function
Predicate   boolean test(T t)   test if a condition is true or false
Supplier    T get()             return an instance of something

BiConsumer void accept(T t, U u)

Collection

A collection is just an object that represents a group of objects.
The Collection interface is the root of the collection hierarchy.
Like most roots in software hierarchies, it's an abstract representation of the behavior you'd need, for managing a
group of objects.
Remember, the interface let's us describe objects by what they can do, rather than what they really look like, or how
they're ultimately constructed.

A QUEUE is a collection designed for holding elements prior to processing, in other words the processing order matters,
so the first and last positions, or the head and tail, are prioritized.

A SET is a collection conceptually based off of a mathematical set.

A MAP is a collection that stores key and value pairs.
 The keys are a set, and the values are a separate collection, where the key keeps a reference to a value.
 Keys need to be unique, but values don't.
 Elements in a tree are stored in a key value Node, also called an Entry.

It's important to understand that the Collections class is not the Collections Framework.
The framework contains many interfaces and implemented classes, as well as helper classes, which this
Collections class is just one example

Hash Code

HashSet and HashMap, are based on the hash codes of objects.
A hash code can be any valid integer, so it could be one of 4.2 billion valid numbers.
A hashing mechanism will take an integer hash code, and a capacity declaration which specifies the number of buckets
to distribute the objects over.
It then translates the range of hash codes into a range of bucket identifiers.
Hashed implementations use a combination of the hash code and other means, to provide the most efficient bucketing
system, to achieve this desired uniform distribution of the objects.
Objects can be considered equal in other instances as well, if their attribute values are equal, for example.
The String class overrides this method, so that it compares all the characters in each String, to confirm that
two Strings are equal.
Objects that are considered equal should produce the same hashCode.

The Set
A Set is not implicitly ordered.
A Set contains no duplicates.
A Set may contain a single null element.
Sets can be useful because operations on them are very fast.
The set interface defines the basic methods add, remove and clear, to maintain the items in the set.
We can also check if a specific item is in the set using the contains method.
Interestingly enough, there's no way to retrieve an item from a set.
You can check if something exists, using contains, and you can iterate over all the elements in the set, but attempting
to get the 10th element, for example, from a set isn't possible, with a single method.

The HashSet class

When you're trying to understand data in multiple sets, you might want to get the data that's in all the sets,
that's in every set, or the data where there's no overlap.
The collection interface's bulk operations (addAll, retainAll, removeAll, and containAll) can be used to perform these
set operations.
If you need an ordered set, you'll want to consider either the LinkedHashSet or the TreeSet.
A LinkedHashSet maintains the insertion order of the elements.
The TreeSet is a sorted collection, sorted by the natural order of the elements, or by specifying the sort during the
creation of the set.
The LinkedHashSet extends the HashSet class.
The iteration order is therefore the same as the insertion order of the elements, meaning the order is predictable.
All the methods for the LinkedHashSet are the same as those for the HashSet.
A TreeSet's class, uses a data structure that's a derivative of what's called a binary search tree, or Btree for short,
which is based on the concept and efficiencies of the binary search
As elements are added to a TreeSet, they're organized in the form of a tree, where the top of the tree represents that
mid point of the elements.
Further binary divisions become nodes under that.
The left node and its children are elements that are less than the parent node.
The right node and its children are elements that are greater than the parent node.
Instead of looking through all the elements in the collection to locate a match, this allows the tree to be
quickly traversed, each node a simple decision point.
The main point is the tree remains balanced as elements are added.
Elements which implement Comparable (said to have a natural order sort, like Strings and numbers) can be elements
of a TreeSet.
If your elements don't implement Comparable, you must pass a Comparator to the constructor.
The TreeSet does offer many advantages, in terms of built-in functionality over the other two Set implementations,
but it does come at a higher cost.
If your number of elements is not large, or you want a collection that's sorted, and continuously re-sorted as you
add and remove elements, and that shouldn't contain duplicate elements, the TreeSet is a good alternative to the ArrayList.

HashMap

A Java Map can't contain duplicate keys.
Each key can only map to a single value.
The HashMap is unordered, the LinkedHashMap is ordered by insertion order, and the TreeMap is a sorted map.


View

The view, or view collection as Java calls it, doesn't store elements, but depends on a backing collection that stores
the data elements.
We know a map has keys, and these can't contain duplicates.
Each key value pair is stored as an instance of an Entry, and the combination of the key and value will be unique,
because the key is unique.
A Set view of these entries, or nodes in the case of the HashMap, can be retrieved from the method entrySet.
You can use the methods remove, removeAll, retainAll, and clear.
It does not support the add or addAll operations.

The Map interface has the LinkedHashMap and TreeMap classes.
The LinkedHashMap is a key value entry collection, whose keys are ordered by insertion order.
The TreeMap is sorted by it's keys, so a key needs to implement Comparable, or be initialized,
with a specified Comparator.


EnumSet and EnumMap

You can use any List, Set, or Map, with an enum constant.
The EnumSet, and EnumMap, each has a special implementation that differs from the HashSet or HashMap.
These implementations make these two types extremely compact and efficient.
There's no special list implementation for enum types
The EnumSet is a specialized Set implementation for use with enum values.
All of the elements in an EnumSet must come from a single enum type.
The EnumSet is abstract, meaning we can't instantiate it directly.
It comes with many factory methods to create instances.
In general, this set has much better performance than using a HashSet, with an enum type.
Bulk operations (such as containsAll and retainAll) should run very quickly, in constant time, O(1), if they're run
on an enumSet, and their argument is an EnumSet.
The Enum Map is a specialized Map implementation for use with enum type keys.
The keys must all come from the same enum type, and they're ordered naturally by the ordinal value of the enum constants.
This map has the same functionality as a HashMap, with O(1) for basic operations.
The enum key type is specified during construction of the EnumMap, either explicitly by passing the key type's class,
or implicitly by passing another EnumSet.
In general, this map has better performance than using a HashMap, with an enum type.

Two Types of EnumSet implementations
Enum sets are represented internally as bit vectors, which is just a series of ones and zeros.
A one indicates that the enum constant (with an ordinal value that is equal to the index of the bit) is in the set.
A zero indicates the enum constant is not in the set.
Using a bit vector allows all set operations to use bit math, which makes it very fast.
A RegularEnumSet uses a single long as its bit vector, which means it can contain a maximum of 64 bits, representing
64 enum values.
A JumboEnumSet gets returned if you have more than 64 enums.












*/



